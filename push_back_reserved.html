<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>

<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en'>
	<head>
		<title>Unchecked push_back and std::vectors of immovable objects</title>
	</head>
	<body>

<h1>Unchecked <tt>push_back</tt> and <tt>std::vector</tt>s of immovable objects</h1>

<ul>
	<li>Document Number: N????</li>
	<li>Date: 2014-??-??</li>
	<li>Project: Programming Language C++, ?? Working Group</li>
	<li>Reply-to:
		<ul>
			<li><a href="mailto:wg21@contacts.eelis.net">Eelis van der Weegen</a></li>
			<li><a href="Victor.Khomenko@ncl.ac.uk">Victor Khomenko</a></li>
		</ul>
	</li>
</ul>

<h2>I. &nbsp; Introduction</h2>

<p>This is a proposal to add new member functions to <tt>std::vector</tt> and <tt>std::basic_string</tt>:</p>
<pre>
    namespace std {

        template &lt;...&gt;
        class vector {
            ...
          public:<span style='color:#00aa00'>

            void push_back<b>_reserved</b>(value_type const &amp;);
            void push_back<b>_reserved</b>(value_type &amp;&amp;);

            template &lt;typename... Args&gt;
            void emplace_back<b>_reserved</b>(Args &amp;&amp; ...);

            static vector of_capacity(size_type); // optional</span>
        };

        template &lt;...&gt;
        class basic_string {
            ...
          public:<span style='color:#00aa00'>

            void push_back<b>_reserved</b>(value_type);</span>
        };
    }
</pre>
<p>The only difference between {<tt>push</tt>, <tt>emplace</tt>}<tt>_back_reserved</tt> and {<tt>push</tt>, <tt>emplace</tt>}<tt>_back</tt> is that the former have as an additional precondition that <tt>size() != capacity()</tt>. This means they can
omit capacity checks, and can assume that no reallocation will be required. This means their
implementation is much simpler and much more efficient.</p>

<p><tt>vector::emplace_back_reserved</tt> enables insertion into vectors of immovable objects, for which the static <tt>of_capacity</tt> utility function would be very helpful; see Section VII.</p>

<h2>II. &nbsp; Motivation</h2>

<p>Suppose we have:</p>
<pre>
    struct X {
        unsigned v;
        X(unsigned v_): v(v_) {}
        X() = delete; // maybe because there is no sensible default value for X
    };
</pre>

<p>And suppose we have some work to do using a vector of these:</p>

<pre>
    unsigned work() {
        auto const n = 256u;

        std::vector&lt;X&gt; a;
        a.reserve(n);
        for (unsigned i = 0; i != n; ++i) a.push_back(i);

        unsigned r = 0;
        for (unsigned i = 0; i != n; ++i) r += a[i].v;
        return r;
    }
</pre>

<p>Great, works like a charm!</p>
<p>But... the call to <tt>push_back</tt> is grossly
inefficient, because <tt>push_back</tt> does a capacity check every time, and
is prepared to reallocate if necessary. Unfortunately, the current
<tt>vector</tt> interface does not let us communicate our knowledge
that the check is unnecessary to the vector.</p>

<h2>III. &nbsp; Rationale</h2>

<p>For subscripting, knowledge that checks are unnecessary <em>can</em> be communicated, by using a separate function: <tt>operator[]</tt> instead of <tt>at()</tt>.
Following this example, we propose separate non-checking versions of the <tt>push_back</tt> and <tt>emplace_back</tt> functions.</p>

<p>The {<tt>push</tt>, <tt>emplace</tt>}<tt>_back_reserved</tt> names are suitably long for
"dangerous" functions, are fairly suggestive of the precondition, and read naturally when
earlier in the code there is a call to <tt>reserve</tt> that establishes said precondition.
But they're just a suggestion &mdash; <tt>unchecked_</tt>{<tt>push</tt>, <tt>emplace</tt>}<tt>_back</tt> also seem popular.</p>

<h2>IV. &nbsp; Implementation</h2>

<p>This is a matter of copy-pasting {<tt>push</tt>, <tt>emplace</tt>}<tt>_back</tt> and removing the capacity checks.</p>

<h2>V. &nbsp; Measurements</h2>

<p>If <tt>work</tt> above is changed to use <tt>push_back_reserved</tt> instead of <tt>push_back</tt>, it runs about twice as fast on a regular Linux desktop machine with either GCC (4.8) or Clang (3.6). Even with such textbook use of <tt>reserve</tt> immediately preceding the <tt>push_back</tt> calls, the optimizers are not nearly clever enough to optimize the checks away.</p>

<h2>VI. &nbsp; Alternatives</h2>

<ul>
	<li><p>Had <tt>X</tt> been default constructible, we could have used <tt>std::vector&lt;X&gt; a(n);</tt> instead.</p><p>Apart from the fact that this does not work for types that are not default constructible, it also means we violate the "prefer initialization over assignment" principle.</p></li>

	<li>
		<p>Use some kind of iterator pair over a virtual sequence of Xs and construct the vector from that.</p>
		<p>
			This is a very roundabout solution that only covers the special case where all the Xs to be inserted are known at the point of construction of the vector.
		</p>
	</li>

	<li>
		<p>Use a custom allocator whose <tt>construct()</tt> is a no-op, then construct the vector with the full size, then construct the fake-constructed elements with placement new.</p>
		<p>This is an extremely roundabout and fragile solution.</p>
	</li>

	<li>
		<p>Abandon <tt>std::vector</tt> and use a custom container.</p>
		<p>
			Several people have suggested this alternative, but <tt>std::vector</tt>
			is supposed to be the standard negligible-overhead answer
			to manually managed dynamically sized buffers, which
			means optimally efficient back insertion for known-capacity cases
			should be a no-brainer.
		</p>
	</li>
</ul>

<h2>VII. &nbsp; Vectors of immovable objects</h2>

<p>Because <tt>std::vector::emplace_back_reserved</tt> does not potentially reallocate, it
does not require movability of the element type. This means we may use it to
populate a vector with non-movable element type, provided we can arrange for capacity somehow.</p>

<p>Making <tt>std::vector</tt> more usable with non-movable element types (such as
one may encounter in legacy code) could be very worthwhile. Unfortunately, we could
not use <tt>reserve</tt> to arrange for capacity in such a vector, because it
requires movability. One inefficient and non-general workaround could be:</p>

<pre>
    std::vector&lt;ImmovableStone&gt; v(n);
        // hopefully no side effects from default constructed stones!

    v.erase(v.begin(), v.end());
        // not clear(), because that may reduce capacity

    assert(v.capacity() &gt;= n);

    v.emplace_back_reserved(...);
    ...
</pre>
<p>Much better would be to have <tt>of_capacity</tt>, because it would let us say:</p>
<pre>
    auto v = std::vector&lt;ImmovableStone&gt;::of_capacity(n);

    v.emplace_back_reserved(...);
    ...
</pre>

<h2>VIII. &nbsp; Possible further additions</h2>
<ul>
	<li>
		<p><tt>reserved_back_inserter</tt> would enable lightning-fast <tt>&lt;algorithm&gt;</tt>-based insertion into vectors with known sufficient capacity.</p>
	</li>
</ul>

<h2>IX. &nbsp; Proposed wording</h2>
<p>Can be provided if there is interest.</p>

<h2>X. &nbsp; Acknowledgements</h2>
<p>Many thanks to the Freenode/##c++ crowd for their ideas/discussion/suggestions!</p>


<h2>XI. &nbsp; References</h2>
<ol>
	<li><a href='https://groups.google.com/a/isocpp.org/d/msg/std-proposals/5BnNHEr07QM/rFgbMSAibioJ'>proposal to add vector::push_back_()</a> (Victor's std-proposals thread from 2013-09-07)</li>
</ol>

	</body>
</html>
